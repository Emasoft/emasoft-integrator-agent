# =============================================================================
# PR Auto-Labeler (Generic Template)
# =============================================================================
#
# WHAT: Automatically labels pull requests based on conventional commit type,
#       size (lines changed), and area (files changed). Keeps labels
#       up to date on every push to the PR.
#
# KEY PATTERNS DEMONSTRATED:
#   - Conventional commit type extraction from PR title
#   - Size classification (XS/S/M/L/XL based on total lines changed)
#   - Area detection from file paths (configurable path prefixes)
#   - Fork PR security check (forks lack write permissions)
#   - Full pagination of changed files (handles PRs with 100+ files)
#   - Idempotent label management (removes stale labels, adds new ones)
#   - ReDoS-safe regex for title parsing
#   - Job summary with applied labels table
#
# HOW TO CUSTOMIZE:
#   - Edit AREA_PATHS to match your project directory structure
#   - Adjust SIZE_THRESHOLDS for your team's definition of "small" vs "large"
#   - Add entries to TYPE_MAP for custom conventional commit types
#   - Create the labels in your repo Settings > Labels before first use
#
# REFERENCE: eia-ci-failure-patterns/references/pr-labeling-strategy.md
# =============================================================================

name: PR Labeler

on:
  pull_request:
    # WHY these types: Label on open, re-label on new commits (synchronize),
    # and re-label on reopen in case labels were cleared.
    types: [opened, synchronize, reopened]

# WHY: If multiple pushes happen rapidly, only the latest labeling matters.
concurrency:
  group: pr-labeler-${{ github.event.pull_request.number }}
  cancel-in-progress: true

# WHY: Minimal permissions. Only needs to read code and write PR labels.
permissions:
  contents: read
  pull-requests: write

jobs:
  label:
    name: Auto Label PR
    runs-on: ubuntu-latest
    # WHY: Fork PRs do not have write access to the base repo's labels.
    # Without this check, the workflow fails with a 403 error on forks.
    if: github.event.pull_request.head.repo.full_name == github.repository
    timeout-minutes: 5

    steps:
      - name: Label PR
        uses: actions/github-script@v7
        with:
          # WHY: Retry on transient GitHub API failures (network, 500s).
          # Do NOT retry on client errors (400, 401, 403, 404, 422).
          retries: 3
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            // =================================================================
            // CONFIGURATION - Edit this section for your project
            // =================================================================

            const CONFIG = {
              // Size thresholds (total lines added + deleted)
              // WHY: Reviewers need to know effort level at a glance.
              // XS = trivial, S = quick review, M = careful review,
              // L = needs multiple reviewers, XL = consider splitting.
              SIZE_THRESHOLDS: {
                XS: 10,    // < 10 lines: typo fixes, config tweaks
                S: 100,    // < 100 lines: single-function changes
                M: 500,    // < 500 lines: feature additions
                L: 1000    // < 1000 lines: large features. >= 1000 = XL
              },

              // Conventional commit type to label mapping
              // WHY: Enables filtering PRs by type in GitHub search/project boards.
              // See: https://www.conventionalcommits.org/
              TYPE_MAP: Object.freeze({
                'feat':     'feature',
                'fix':      'bug',
                'docs':     'documentation',
                'refactor': 'refactor',
                'test':     'test',
                'ci':       'ci',
                'chore':    'chore',
                'perf':     'performance',
                'style':    'style',
                'build':    'build'
              }),

              // Area detection: map path prefixes to area names
              // WHY: Helps route PRs to the right reviewers automatically.
              // CUSTOMIZE: Replace these paths with your project structure.
              AREA_PATHS: Object.freeze({
                frontend: 'src/frontend/',
                backend:  'src/backend/',
                ci:       '.github/',
                docs:     'docs/'
              }),

              // Label names used by this workflow
              // WHY: Centralized so you can rename labels in one place.
              LABELS: Object.freeze({
                SIZE: ['size/XS', 'size/S', 'size/M', 'size/L', 'size/XL'],
                AREA: ['area/frontend', 'area/backend', 'area/fullstack', 'area/ci', 'area/docs']
              }),

              // WHY: GitHub API returns max 100 files per page. We use
              // pagination to handle PRs that touch more than 100 files.
              MAX_FILES_PER_PAGE: 100
            };

            // =================================================================
            // HELPER FUNCTIONS
            // =================================================================

            /**
             * Parse conventional commit type from PR title.
             * Returns {type, isBreaking} or {null, false} if not conventional.
             *
             * WHY ReDoS-safe regex: Untrusted input (PR titles) must use
             * bounded quantifiers. An unbounded regex like /^(\w+)(\(.*\))?!?:/
             * can be exploited with crafted titles to cause exponential backtracking.
             */
            function parseConventionalCommit(title) {
              if (!title || typeof title !== 'string') {
                return { type: null, isBreaking: false };
              }

              // Limit input length to prevent ReDoS attacks
              const safeTitle = title.slice(0, 200);
              // Bounded quantifiers: \w{1,20} and [^)]{0,50} prevent backtracking
              const match = safeTitle.match(/^(\w{1,20})(\([^)]{0,50}\))?(!)?:/);

              if (!match) {
                return { type: null, isBreaking: false };
              }

              return {
                type: match[1].toLowerCase(),
                isBreaking: match[3] === '!'
              };
            }

            /**
             * Determine size label from total lines changed.
             */
            function determineSizeLabel(totalLines) {
              const { SIZE_THRESHOLDS } = CONFIG;
              if (totalLines < SIZE_THRESHOLDS.XS) return 'size/XS';
              if (totalLines < SIZE_THRESHOLDS.S)  return 'size/S';
              if (totalLines < SIZE_THRESHOLDS.M)  return 'size/M';
              if (totalLines < SIZE_THRESHOLDS.L)  return 'size/L';
              return 'size/XL';
            }

            /**
             * Detect which project areas are touched by the changed files.
             */
            function detectAreas(files) {
              const areas = {};
              for (const key of Object.keys(CONFIG.AREA_PATHS)) {
                areas[key] = false;
              }

              for (const file of files) {
                const path = file.filename || '';
                for (const [area, prefix] of Object.entries(CONFIG.AREA_PATHS)) {
                  if (path.startsWith(prefix)) areas[area] = true;
                }
              }
              return areas;
            }

            /**
             * Determine the single area label to apply.
             * WHY "fullstack": If both frontend and backend are touched,
             * a combined label signals the PR needs cross-team review.
             */
            function determineAreaLabel(areas) {
              if (areas.frontend && areas.backend) return 'area/fullstack';
              if (areas.frontend) return 'area/frontend';
              if (areas.backend)  return 'area/backend';
              if (areas.ci)       return 'area/ci';
              if (areas.docs)     return 'area/docs';
              return null;
            }

            /**
             * Remove labels from PR, ignoring 404 (label not present).
             */
            async function removeLabels(labels, prNumber) {
              const { owner, repo } = context.repo;
              await Promise.allSettled(labels.map(async (label) => {
                try {
                  await github.rest.issues.removeLabel({
                    owner, repo, issue_number: prNumber, name: label
                  });
                } catch (e) {
                  // 404 = label was not on the PR, which is fine
                  if (e.status !== 404) {
                    console.log(`Warning: Failed to remove ${label}: ${e.message}`);
                  }
                }
              }));
            }

            /**
             * Add labels to PR. Warns if labels do not exist in the repo.
             */
            async function addLabels(labels, prNumber) {
              if (labels.length === 0) return;
              const { owner, repo } = context.repo;
              try {
                await github.rest.issues.addLabels({
                  owner, repo, issue_number: prNumber, labels
                });
              } catch (e) {
                if (e.status === 404) {
                  core.warning('One or more labels do not exist. Create them in Settings > Labels.');
                } else {
                  throw e;
                }
              }
            }

            /**
             * Fetch ALL changed files using pagination.
             * WHY pagination: GitHub returns max 100 files per page.
             * Without pagination, large PRs only see the first 100 files,
             * causing incorrect area detection.
             */
            async function fetchPRFiles(prNumber) {
              const { owner, repo } = context.repo;
              try {
                return await github.paginate(
                  github.rest.pulls.listFiles,
                  { owner, repo, pull_number: prNumber, per_page: CONFIG.MAX_FILES_PER_PAGE }
                );
              } catch (e) {
                console.log(`Warning: Could not fetch files: ${e.message}`);
                return [];
              }
            }

            // =================================================================
            // MAIN LOGIC
            // =================================================================

            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            const title = pr.title || '';

            console.log(`::group::PR #${prNumber} - Auto-labeling`);
            console.log(`Title: ${title.slice(0, 100)}`);

            const labelsToAdd = new Set();
            const labelsToRemove = new Set();

            // Step 1: Parse conventional commit type from title
            const { type, isBreaking } = parseConventionalCommit(title);
            if (type && CONFIG.TYPE_MAP[type]) {
              labelsToAdd.add(CONFIG.TYPE_MAP[type]);
              console.log(`  Type: ${type} -> ${CONFIG.TYPE_MAP[type]}`);
            }
            if (isBreaking) {
              labelsToAdd.add('breaking-change');
              console.log(`  Breaking change detected`);
            }

            // Step 2: Detect areas from changed files
            const files = await fetchPRFiles(prNumber);
            const areas = detectAreas(files);
            const areaLabel = determineAreaLabel(areas);
            if (areaLabel) {
              labelsToAdd.add(areaLabel);
              // WHY remove other area labels: Area can change between pushes.
              // Idempotent removal ensures only the current area label remains.
              CONFIG.LABELS.AREA.filter(l => l !== areaLabel)
                .forEach(l => labelsToRemove.add(l));
              console.log(`  Area: ${areaLabel}`);
            }

            // Step 3: Calculate size label
            const totalLines = (pr.additions || 0) + (pr.deletions || 0);
            const sizeLabel = determineSizeLabel(totalLines);
            labelsToAdd.add(sizeLabel);
            // WHY remove other size labels: Size changes between pushes.
            CONFIG.LABELS.SIZE.filter(l => l !== sizeLabel)
              .forEach(l => labelsToRemove.add(l));
            console.log(`  Size: ${sizeLabel} (${totalLines} lines)`);

            console.log('::endgroup::');

            // Step 4: Apply label changes (remove stale, add new)
            const removeList = [...labelsToRemove].filter(l => !labelsToAdd.has(l));
            await removeLabels(removeList, prNumber);
            await addLabels([...labelsToAdd], prNumber);

            // Step 5: Write job summary for the Actions UI
            const summaryType = type ? CONFIG.TYPE_MAP[type] || 'unknown' : 'none';
            const summaryArea = areaLabel ? areaLabel.replace('area/', '') : 'other';

            await core.summary
              .addHeading(`PR #${prNumber} Auto-Labels`, 3)
              .addTable([
                [{ data: 'Category', header: true }, { data: 'Label', header: true }],
                ['Type', summaryType],
                ['Area', summaryArea],
                ['Size', sizeLabel]
              ])
              .addRaw(`\n**Files:** ${files.length} | **Lines:** +${pr.additions || 0} / -${pr.deletions || 0}\n`)
              .write();
