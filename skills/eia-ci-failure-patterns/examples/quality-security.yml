# =============================================================================
# Quality & Security Scanning Pipeline (Generic Template)
# =============================================================================
#
# WHAT: Runs CodeQL static analysis for multiple languages and Bandit for
#       Python-specific security scanning. Blocks PRs on high-severity issues.
#
# KEY PATTERNS DEMONSTRATED:
#   - CodeQL matrix for multiple languages (Python + JavaScript/TypeScript)
#   - `security-extended` and `security-and-quality` query suites
#   - Scheduled weekly scan (cron) to catch newly disclosed vulnerabilities
#   - Bandit for Python with severity-based filtering (only HIGH blocks)
#   - Programmatic Bandit result analysis with structured JSON
#   - Structured job summary with severity table
#   - Gate job with skipped-is-acceptable logic
#   - Timeout guards on long-running analysis jobs
#
# HOW TO CUSTOMIZE:
#   - Add/remove languages in the CodeQL matrix (go, java, ruby, etc.)
#   - Adjust Bandit severity threshold (currently blocks on HIGH only)
#   - Change the weekly scan schedule (cron expression)
#   - Replace `src/backend/` with your Python source path
#   - Add additional security tools (Semgrep, Trivy, etc.) as new jobs
#
# REFERENCE: eia-ci-failure-patterns/references/security-scanning.md
#            eia-ci-failure-patterns/references/gate-job-pattern.md
# =============================================================================

name: Quality Security

# WHY three triggers:
# - push to main: Scan code that just merged (catches issues in merge commits)
# - pull_request: Block PRs with security issues before merge
# - schedule: Weekly scan catches newly disclosed CVEs in existing code
on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'tests/**'
      - 'pyproject.toml'
      - 'package.json'
      - '.github/workflows/quality-security.yml'
  pull_request:
    branches: [main, develop]
    paths:
      - 'src/**'
      - 'tests/**'
      - 'pyproject.toml'
      - 'package.json'
      - '.github/workflows/quality-security.yml'
  schedule:
    # WHY weekly: Daily is too noisy, monthly misses critical CVEs.
    # Monday midnight UTC catches issues at the start of the work week.
    - cron: '0 0 * * 1'

# WHY: Cancel duplicate runs for the same branch/PR.
# Security scans can take 20-60 minutes, so cancellation saves real time.
concurrency:
  group: security-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# WHY these permissions:
# - contents:read: Clone the repo
# - security-events:write: Upload SARIF results to GitHub Security tab
# - actions:read: Required by CodeQL for workflow information
permissions:
  contents: read
  security-events: write
  actions: read

jobs:
  # --------------------------------------------------------------------------
  # CodeQL Analysis - Multiple Languages
  # --------------------------------------------------------------------------
  # WHY CodeQL: GitHub-native SAST (Static Application Security Testing).
  # Results appear in the Security tab and can block PRs via branch protection.
  codeql:
    name: CodeQL (${{ matrix.language }})
    runs-on: ubuntu-latest
    # WHY timeout: CodeQL can hang on complex codebases. 30 minutes is
    # generous but prevents infinite runs that consume all CI minutes.
    timeout-minutes: 30

    strategy:
      fail-fast: false
      matrix:
        # WHY matrix: Each language is analyzed independently. If Python
        # analysis fails, JavaScript analysis still runs and reports.
        # Available languages: cpp, csharp, go, java-kotlin, javascript-typescript, python, ruby, swift
        language: [python, javascript-typescript]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language }}
          # WHY +security-extended: Adds extra security queries beyond default.
          # WHY +security-and-quality: Adds code quality queries (dead code,
          # unused variables, etc.) that also have security implications.
          queries: +security-extended,security-and-quality

      # WHY autobuild: CodeQL needs to understand your build process to
      # analyze compiled languages. For interpreted languages (Python, JS),
      # autobuild is essentially a no-op but still required.
      - name: Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          # WHY category: Separates results per language in the Security tab.
          # Without this, results from different languages would be mixed.
          category: "/language:${{ matrix.language }}"

  # --------------------------------------------------------------------------
  # Python Security Scanning with Bandit
  # --------------------------------------------------------------------------
  # WHY Bandit in addition to CodeQL: Bandit is Python-specific and catches
  # issues CodeQL may miss (eval usage, weak crypto, insecure temp files).
  # It runs in 5-10 minutes vs 20-30 for CodeQL.
  python-security:
    name: Python Security (Bandit)
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Bandit
        run: pip install bandit

      - name: Run Bandit security scan
        id: bandit
        run: |
          echo "::group::Running Bandit security scan"
          # -r: Recursive scan
          # -ll: Only report MEDIUM and above (skip LOW noise)
          # -ii: Only report MEDIUM confidence and above
          # -f json: Machine-readable output for programmatic analysis
          # -o: Write to file for the analysis step
          # WHY `|| BANDIT_EXIT=$?`: Bandit exits 1 if it finds issues.
          # We capture the exit code instead of failing immediately so
          # the analysis step can determine severity-based pass/fail.
          bandit -r src/backend/ -ll -ii -f json -o bandit-report.json || BANDIT_EXIT=$?
          if [ "${BANDIT_EXIT:-0}" -gt 1 ]; then
            echo "::error::Bandit scan crashed with exit code $BANDIT_EXIT"
            exit 1
          fi
          echo "::endgroup::"

      - name: Analyze Bandit results
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            if (!fs.existsSync('bandit-report.json')) {
              core.setFailed('Bandit report not found - scan may have failed');
              return;
            }

            const report = JSON.parse(fs.readFileSync('bandit-report.json', 'utf8'));
            const results = report.results || [];

            // Categorize by severity for the summary table
            const high   = results.filter(r => r.issue_severity === 'HIGH');
            const medium = results.filter(r => r.issue_severity === 'MEDIUM');
            const low    = results.filter(r => r.issue_severity === 'LOW');

            console.log(`::group::Bandit Security Scan Results`);
            console.log(`Found ${results.length} issues:`);
            console.log(`  HIGH:   ${high.length}`);
            console.log(`  MEDIUM: ${medium.length}`);
            console.log(`  LOW:    ${low.length}`);
            console.log('::endgroup::');

            // Build structured job summary with severity table
            let summary = `## Python Security Scan (Bandit)\n\n`;
            summary += `| Severity | Count |\n`;
            summary += `|----------|-------|\n`;
            summary += `| High | ${high.length} |\n`;
            summary += `| Medium | ${medium.length} |\n`;
            summary += `| Low | ${low.length} |\n\n`;

            // List high-severity issues with file locations
            if (high.length > 0) {
              summary += `### High Severity Issues\n\n`;
              for (const issue of high) {
                summary += `- **${issue.filename}:${issue.line_number}**\n`;
                summary += `  - ${issue.issue_text}\n`;
                summary += `  - Test: \`${issue.test_id}\` (${issue.test_name})\n\n`;
              }
            }

            core.summary.addRaw(summary);
            await core.summary.write();

            // WHY only HIGH blocks: MEDIUM/LOW findings are informational.
            // Blocking on everything creates alert fatigue and slows development.
            // Teams should triage MEDIUM findings periodically.
            if (high.length > 0) {
              core.setFailed(`Found ${high.length} high severity security issue(s)`);
            } else {
              console.log('No high severity security issues found');
            }

  # --------------------------------------------------------------------------
  # Gate Job - Aggregates all security results
  # --------------------------------------------------------------------------
  security-summary:
    name: Security Summary
    runs-on: ubuntu-latest
    needs: [codeql, python-security]
    # WHY `if: always()`: Must run even when upstream jobs fail or are skipped.
    if: always()
    timeout-minutes: 5

    steps:
      - name: Check security results
        uses: actions/github-script@v7
        with:
          script: |
            const codeql = '${{ needs.codeql.result }}';
            const bandit = '${{ needs.python-security.result }}';

            console.log('Security Check Results:');
            console.log(`  CodeQL: ${codeql}`);
            console.log(`  Bandit: ${bandit}`);

            // WHY 'skipped' is acceptable: Path filters may skip CodeQL on
            // docs-only PRs. Scheduled runs may skip Bandit. These are
            // legitimate skips, not failures. Only 'failure' is a real problem.
            const acceptable = ['success', 'skipped'];
            const allPassed = acceptable.includes(codeql) && acceptable.includes(bandit);

            let summary = '';
            if (allPassed) {
              summary = '## Security Checks Passed\n\nAll security scans completed successfully.';
              console.log('All security checks passed');
            } else {
              summary = '## Security Checks Failed\n\nOne or more security scans found issues.';
              core.setFailed('Security checks failed');
            }

            core.summary.addRaw(summary);
            await core.summary.write();
