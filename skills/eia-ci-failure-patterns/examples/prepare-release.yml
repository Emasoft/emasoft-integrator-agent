# =============================================================================
# Prepare Release Pipeline (Generic Template)
# =============================================================================
#
# WHAT: Compares the project version against the latest git tag. If the
#       version is newer, validates CHANGELOG.md, extracts release notes,
#       and creates an annotated git tag that triggers a release workflow.
#
# KEY PATTERNS DEMONSTRATED:
#   - Version comparison against latest git tag (semver-aware)
#   - CHANGELOG.md validation as a release gate (no changelog = no release)
#   - AWK-based changelog section extraction
#   - PAT_TOKEN for cross-workflow tag push (GITHUB_TOKEN cannot trigger workflows)
#   - Annotated git tags (not lightweight) for release metadata
#   - workflow_dispatch with force option for manual re-triggers
#   - Artifact upload for passing data to downstream release workflow
#   - Detailed job summaries for success, failure, and skip scenarios
#   - Generic version extraction (both package.json and pyproject.toml shown)
#
# HOW TO CUSTOMIZE:
#   - Choose your version source: package.json (Node.js) or pyproject.toml (Python)
#   - Set up PAT_TOKEN secret in Settings > Secrets > Actions
#   - Adjust CHANGELOG.md format to match your project conventions
#   - Add build/test steps before tag creation if desired
#   - Wire up the downstream release.yml to trigger on tag push (v*)
#
# REFERENCE: eia-ci-failure-patterns/references/release-pipeline.md
#            eia-ci-failure-patterns/references/changelog-validation.md
# =============================================================================

name: Prepare Release

on:
  push:
    branches: [main]
    paths:
      # WHY: Only trigger when version files change. This prevents
      # release checks on every single merge to main.
      # CUSTOMIZE: Use one or both depending on your project type.
      - 'package.json'           # Node.js/TypeScript projects
      - 'pyproject.toml'         # Python projects
  workflow_dispatch:
    inputs:
      force:
        description: 'Force release even if version check fails (use with caution)'
        required: false
        default: false
        type: boolean

jobs:
  check-and-tag:
    runs-on: ubuntu-latest
    # WHY contents:write: Needed to push the git tag.
    permissions:
      contents: write
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      new_version: ${{ steps.check.outputs.new_version }}

    steps:
      # WHY: Fail fast with a clear error if PAT_TOKEN is missing.
      # Without PAT_TOKEN, the tag push will succeed but will NOT trigger
      # downstream workflows (this is a GitHub security feature).
      - name: Validate PAT_TOKEN is configured
        run: |
          if [ -z "${{ secrets.PAT_TOKEN }}" ]; then
            echo "::error::PAT_TOKEN secret is not configured."
            echo "::error::This secret is required for the tag push to trigger the release workflow."
            echo "::error::Create a Personal Access Token with 'repo' scope and add it as a secret."
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Release Blocked: Missing PAT_TOKEN" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The PAT_TOKEN secret is required for automatic release triggering." >> $GITHUB_STEP_SUMMARY
            echo "See repository Settings > Secrets > Actions to configure it." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      # WHY: Use PAT_TOKEN instead of GITHUB_TOKEN for checkout.
      # When GITHUB_TOKEN pushes a tag, GitHub does NOT trigger other
      # workflows (security feature to prevent infinite loops). PAT_TOKEN
      # allows the tag push to trigger release.yml automatically.
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # WHY fetch-depth 0: Need full history to find the latest tag.
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN }}

      # =====================================================================
      # VERSION EXTRACTION
      # Choose ONE of the following blocks based on your project type.
      # =====================================================================

      # --- Option A: Node.js / TypeScript (package.json) ---
      - name: Get project version (from package.json)
        id: package
        run: |
          # WHY `node -p`: Native JSON parsing, no jq dependency needed.
          # CUSTOMIZE: Change the path if package.json is in a subdirectory.
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Project version: $VERSION"

      # --- Option B: Python (pyproject.toml) - UNCOMMENT to use instead ---
      # - name: Get project version (from pyproject.toml)
      #   id: package
      #   run: |
      #     # WHY grep+sed: Avoids installing toml parsing libraries.
      #     # Matches: version = "1.2.3" or version = '1.2.3'
      #     VERSION=$(grep -m1 '^version' pyproject.toml | sed 's/.*["'"'"']\(.*\)["'"'"'].*/\1/')
      #     if [ -z "$VERSION" ]; then
      #       echo "::error::Could not extract version from pyproject.toml"
      #       exit 1
      #     fi
      #     echo "version=$VERSION" >> $GITHUB_OUTPUT
      #     echo "Project version: $VERSION"

      - name: Get latest tag version
        id: latest_tag
        run: |
          # WHY: Find the most recent version tag to compare against.
          # `--sort=-version:refname` sorts semantically (2.10.0 > 2.9.0).
          LATEST_TAG=$(git tag -l 'v*' --sort=-version:refname | head -n1)
          if [ -z "$LATEST_TAG" ]; then
            echo "No existing tags found - first release"
            echo "version=0.0.0" >> $GITHUB_OUTPUT
          else
            # Strip the 'v' prefix for numeric comparison
            LATEST_VERSION=${LATEST_TAG#v}
            echo "version=$LATEST_VERSION" >> $GITHUB_OUTPUT
            echo "Latest tag: $LATEST_TAG (version: $LATEST_VERSION)"
          fi

      - name: Check if release needed
        id: check
        run: |
          PACKAGE_VERSION="${{ steps.package.outputs.version }}"
          LATEST_VERSION="${{ steps.latest_tag.outputs.version }}"
          FORCE="${{ github.event.inputs.force }}"

          echo "Comparing: package=$PACKAGE_VERSION vs latest_tag=$LATEST_VERSION"

          # WHY npx semver: Proper semantic version comparison that handles
          # pre-release versions correctly (2.7.3 > 2.7.3-beta.1).
          # For Python projects, you could use `python -c "from packaging.version import Version; ..."` instead.
          if npx -y semver "$PACKAGE_VERSION" -r ">$LATEST_VERSION" > /dev/null 2>&1; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "new_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
            echo "New release needed: v$PACKAGE_VERSION"
          elif [ "$FORCE" = "true" ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "new_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
            echo "Force release enabled: v$PACKAGE_VERSION"
          else
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "No release needed (package version not newer than latest tag)"
          fi

      # WHY: CHANGELOG validation is a release gate. Forces developers to
      # document what changed before releasing. Without this, releases go
      # out with no documentation and users have no idea what changed.
      - name: Validate and extract changelog
        if: steps.check.outputs.should_release == 'true'
        id: changelog
        run: |
          VERSION="${{ steps.check.outputs.new_version }}"
          CHANGELOG_FILE="CHANGELOG.md"

          echo "Validating CHANGELOG.md for version $VERSION..."

          if [ ! -f "$CHANGELOG_FILE" ]; then
            echo "::error::CHANGELOG.md not found! Create it with release notes."
            exit 1
          fi

          # WHY AWK: Extracts the section between two `## X.Y.Z` headers.
          # This is the standard Keep a Changelog format.
          # Looks for "## X.Y.Z" and captures until the next "## " or "---" or EOF.
          CHANGELOG_CONTENT=$(awk -v ver="$VERSION" '
            BEGIN { found=0; content="" }
            /^## / {
              if (found) exit
              if ($2 == ver || $2 ~ "^"ver"[[:space:]]*-") {
                found=1
                next
              }
            }
            /^---$/ { if (found) exit }
            found { content = content $0 "\n" }
            END {
              if (!found) { print "NOT_FOUND"; exit 1 }
              gsub(/^[[:space:]]+|[[:space:]]+$/, "", content)
              print content
            }
          ' "$CHANGELOG_FILE")

          if [ "$CHANGELOG_CONTENT" = "NOT_FOUND" ] || [ -z "$CHANGELOG_CONTENT" ]; then
            echo "::error::Version $VERSION not found in CHANGELOG.md!"
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Release Blocked: Missing Changelog" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Version **$VERSION** was not found in CHANGELOG.md." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### How to fix" >> $GITHUB_STEP_SUMMARY
            echo "1. Add a \`## $VERSION\` section to CHANGELOG.md" >> $GITHUB_STEP_SUMMARY
            echo "2. Commit and push the changes" >> $GITHUB_STEP_SUMMARY
            echo "3. The release will automatically retry" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          echo "Found changelog entry for version $VERSION"

          # Save to file for artifact upload (survives across jobs)
          echo "$CHANGELOG_CONTENT" > changelog-extract.md

          # Also save to output for same-job access
          {
            echo "content<<CHANGELOG_EOF"
            echo "$CHANGELOG_CONTENT"
            echo "CHANGELOG_EOF"
          } >> $GITHUB_OUTPUT

          echo "changelog_valid=true" >> $GITHUB_OUTPUT

      # WHY artifact: The release workflow (triggered by tag push) runs as
      # a separate workflow and cannot access this job's outputs. Artifacts
      # are the standard way to pass data between workflows.
      - name: Upload changelog artifact
        if: steps.check.outputs.should_release == 'true' && steps.changelog.outputs.changelog_valid == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: changelog-${{ steps.check.outputs.new_version }}
          path: changelog-extract.md
          # WHY 1 day: The release workflow should pick this up within minutes.
          # Short retention avoids accumulating old artifacts.
          retention-days: 1

      - name: Create and push annotated tag
        if: steps.check.outputs.should_release == 'true' && steps.changelog.outputs.changelog_valid == 'true'
        run: |
          VERSION="${{ steps.check.outputs.new_version }}"
          TAG="v$VERSION"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          echo "Creating annotated tag: $TAG"
          # WHY annotated (-a): Annotated tags store metadata (author, date,
          # message). Lightweight tags are just pointers. Release tags should
          # always be annotated for auditability.
          git tag -a "$TAG" -m "Release $TAG"
          git push origin "$TAG"

          echo "Tag $TAG created and pushed"
          echo "This will trigger the release workflow"

      - name: Job summary
        run: |
          if [ "${{ steps.check.outputs.should_release }}" = "true" ] && \
             [ "${{ steps.changelog.outputs.changelog_valid }}" = "true" ]; then
            echo "## Release Triggered" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Version:** v${{ steps.check.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Changelog validated and extracted from CHANGELOG.md" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.check.outputs.should_release }}" = "false" ]; then
            echo "## No Release Needed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Current version:** ${{ steps.package.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "**Latest tag:** v${{ steps.latest_tag.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The project version is not newer than the latest tag." >> $GITHUB_STEP_SUMMARY
            echo "Bump the version in your project file and push to trigger a release." >> $GITHUB_STEP_SUMMARY
          fi
