#!/usr/bin/env python3
"""Quick code scan template generator for code reviews.

Generates a quick scan report template based on the two-stage review methodology.
Used for Stage One: rapid identification of critical blockers and obvious issues.

Usage:
    python quick-scan-template.py --repo myproject --pr 123 --files-changed 15
    python quick-scan-template.py -r myproject -p 123 -f 15 --lines-added 450 --lines-removed 120
    python quick-scan-template.py -r myproject -p 123 -f 15 -o quick-scan-report.md
"""

# WHY: Future annotations enable PEP 604 style unions (X | None) and forward references
from __future__ import annotations

import sys
import argparse
from pathlib import Path
from typing import Optional
from dataclasses import dataclass

# WHY: 20-minute timeout prevents hung processes during long scans while allowing large PRs
COMMAND_TIMEOUT = 1200  # seconds


@dataclass
class QuickScanInput:
    """Input parameters for quick scan template generation."""

    repo_name: str
    pr_number: int
    files_changed: int
    lines_added: int = 0
    lines_removed: int = 0
    output_file: Optional[Path] = None


def classify_pr_size(files_changed: int) -> str:
    """
    Classify PR size based on number of files changed.

    Args:
        files_changed: Number of files modified in the PR

    Returns:
        Size classification: 'Small', 'Medium', or 'Large'
    """
    if files_changed <= 10:
        return "Small"
    elif files_changed <= 30:
        return "Medium"
    else:
        return "Large"


def generate_quick_scan_template(scan_input: QuickScanInput) -> str:
    """
    Generate a quick scan report template.

    Args:
        scan_input: QuickScanInput dataclass with PR information

    Returns:
        Formatted quick scan template as string
    """
    pr_size = classify_pr_size(scan_input.files_changed)
    total_lines = scan_input.lines_added + scan_input.lines_removed

    # Determine if magnitude is concerning
    magnitude_status = "PASS"
    if total_lines > 500:
        magnitude_status = "CONCERN"

    template = f"""QUICK SCAN RESULT
=================
Repository: {scan_input.repo_name}
Pull Request: #{scan_input.pr_number}
Files Changed: {scan_input.files_changed} ({pr_size} PR)
Lines Added/Removed: +{scan_input.lines_added} -{scan_input.lines_removed}

SCAN FINDINGS:
--------------
- File structure: [PASS/CONCERN]
  * Review file types and check for suspicious additions
  * Look for credentials, large binaries, or unexpected file types

- Diff magnitude: [{magnitude_status}]
  * Total lines changed: {total_lines}
  * Flag any files with >500 lines changed
  * Check if changes are focused or scattered

- Obvious issues: [PASS/CONCERN/ISSUES FOUND]
  * [ ] Check for syntax errors or typos
  * [ ] Scan for commented-out code blocks
  * [ ] Look for leftover debug statements (console.log, print, etc.)
  * [ ] Check for TODO/FIXME markers indicating incomplete work

- Red flags: [NONE/FLAGGED]
  * [ ] Check for disabled security checks or linting rules
  * [ ] Verify no tests removed without replacement
  * [ ] Scan for hard-coded credentials or sensitive data
  * [ ] Look for breaking changes to public APIs without versioning
  * [ ] Check for circular dependencies or import cycles

RED FLAGS DETECTED:
-------------------
[List any critical issues found during scan]
- None detected (update after review)

DETAILED FINDINGS:
------------------
[Add specific findings here]

1. File Structure Assessment:
   -

2. Diff Magnitude Review:
   -

3. Obvious Issues:
   -

4. Critical Red Flags:
   -

QUICK SCAN CONFIDENCE: [70-100%]
--------------------------------
Confidence Score: ___%
Reasoning: [Explain confidence level based on findings]

NEXT STEP: [PROCEED TO STAGE TWO / REQUEST CLARIFICATION]
----------------------------------------------------------
Decision:
Rationale:

If proceeding to Stage Two:
  - All critical blockers addressed or acceptable
  - No obvious issues that would immediately fail review
  - Confidence >= 70%

If requesting clarification:
  - Specific questions for PR author:
    1.
    2.
    3.

---
Generated by quick-scan-template.py
Review Date: [Add date]
Reviewer: [Add name]
"""

    return template


def verify_output_file(file_path: Path, expected_min_size: int = 100) -> bool:
    """
    Verify that an output file was written correctly.

    WHY: File writes can silently fail (disk full, permissions, etc). Always verify.

    Args:
        file_path: Path to the file to verify
        expected_min_size: Minimum expected file size in bytes

    Returns:
        True if file exists and meets size requirement, False otherwise
    """
    if not file_path.exists():
        print(f"ERROR: Output file does not exist: {file_path}", file=sys.stderr)
        return False

    file_size = file_path.stat().st_size
    if file_size < expected_min_size:
        print(
            f"ERROR: Output file too small ({file_size} bytes, expected >= {expected_min_size}): {file_path}",
            file=sys.stderr,
        )
        return False

    return True


def main() -> None:
    """Main entry point for quick scan template generator.

    WHY: Exits via sys.exit() for clear automation integration (0=success, 1=failure).
    """
    parser = argparse.ArgumentParser(
        description="Generate quick scan report template for code reviews",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --repo myproject --pr 123 --files-changed 15
  %(prog)s -r myproject -p 123 -f 15 --lines-added 450 --lines-removed 120
  %(prog)s -r myproject -p 123 -f 15 -o quick-scan-report.md
        """,
    )

    parser.add_argument("--repo", "-r", type=str, required=True, help="Repository name")

    parser.add_argument(
        "--pr", "-p", type=int, required=True, help="Pull request number"
    )

    parser.add_argument(
        "--files-changed",
        "-f",
        type=int,
        required=True,
        help="Number of files changed in the PR",
    )

    parser.add_argument(
        "--lines-added",
        "-a",
        type=int,
        default=0,
        help="Number of lines added (default: 0)",
    )

    parser.add_argument(
        "--lines-removed",
        "-d",
        type=int,
        default=0,
        help="Number of lines removed (default: 0)",
    )

    parser.add_argument(
        "--output", "-o", type=Path, help="Output file path (default: print to stdout)"
    )

    args = parser.parse_args()

    # Create input dataclass
    scan_input = QuickScanInput(
        repo_name=args.repo,
        pr_number=args.pr,
        files_changed=args.files_changed,
        lines_added=args.lines_added,
        lines_removed=args.lines_removed,
        output_file=args.output,
    )

    # Generate template
    template = generate_quick_scan_template(scan_input)

    # WHY: Output to file enables integration with review workflows; stdout for piping
    if args.output:
        try:
            args.output.write_text(template, encoding="utf-8")
        except (OSError, IOError) as e:
            print(f"ERROR: Failed to write output file: {e}", file=sys.stderr)
            sys.exit(1)

        # WHY: Always verify file writes to catch silent failures (disk full, permissions)
        if not verify_output_file(args.output):
            sys.exit(1)

        print(f"Quick scan template written to: {args.output}")
    else:
        print(template)

    # WHY: Explicit exit codes make script behavior clear in automation pipelines
    sys.exit(0)


if __name__ == "__main__":
    # WHY: Direct call since main() handles its own exit codes via sys.exit()
    main()
