#!/usr/bin/env python3
"""
int_github_lifecycle_issues.py - Issue operations for GitHub lifecycle automation.

This module provides functions for:
- Creating issues from design specs
- Attaching design documents to issues
- Searching and verifying issues

Part of the Integrator GitHub Lifecycle Automation suite.
"""

import json
import re
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional

from int_github_lifecycle_core import (
    DesignDocument,
    IssueMetadata,
    run_gh_command,
    parse_design_document,
    sanitize_content,
    validate_frontmatter,
    validate_documents,
)

__all__ = [
    "create_issue_from_spec",
    "attach_document_to_issue",
    "attach_multiple_documents",
    "get_issue_info",
    "search_issues",
    "verify_closure_requirements",
]


def create_issue_from_spec(
    spec_path: Path,
    project_number: Optional[int] = None,
    labels: Optional[list[str]] = None,
    assignees: Optional[list[str]] = None,
    sanitize: bool = True,
) -> Optional[int]:
    """Create a GitHub issue from a design spec. Returns the issue number if successful."""
    doc = parse_design_document(spec_path)
    if not doc:
        print(f"ERROR: Could not parse spec: {spec_path}", file=sys.stderr)
        return None

    title = f"[{doc.doc_type.upper()}] {doc.title}"
    if doc.uuid:
        title = f"[{doc.uuid}] {doc.title}"

    body_content = doc.content if not sanitize else sanitize_content(doc.content)
    body = f"""## Design Specification

**UUID**: `{doc.uuid}`
**Type**: {doc.doc_type}
**Status**: {doc.status}
**Source**: `{spec_path}`

---

{body_content}

---
*Generated by Integrator Agent*
"""

    cmd: list[str] = ["issue", "create", "--title", title, "--body", body]

    if labels:
        for label in labels:
            cmd.extend(["--label", label])
    cmd.extend(["--label", f"type:{doc.doc_type}"])

    if assignees:
        for assignee in assignees:
            cmd.extend(["--assignee", assignee])

    if project_number:
        cmd.extend(["--project", str(project_number)])

    result = run_gh_command(cmd)
    if result.returncode != 0:
        print(f"ERROR: Failed to create issue: {result.stderr}", file=sys.stderr)
        return None

    url = result.stdout.strip()
    match = re.search(r"/issues/(\d+)", url)
    if match:
        issue_num = int(match.group(1))
        print(f"CREATED: Issue #{issue_num} - {title}")
        print(f"URL: {url}")
        return issue_num

    return None


def attach_document_to_issue(
    issue_number: int,
    doc_path: Path,
    sanitize: bool = True,
    comment_prefix: str = "",
    validate: bool = True,
    strict: bool = False,
) -> bool:
    """Attach a design document as an issue comment. Returns True if successful."""
    if validate:
        validation = validate_frontmatter(doc_path, strict=strict)
        if not validation.valid:
            print(f"ERROR: Document validation failed for {doc_path}:", file=sys.stderr)
            for error in validation.errors:
                print(f"  - {error}", file=sys.stderr)
            print(
                "Use --no-validate to skip validation (not recommended)",
                file=sys.stderr,
            )
            return False
        if validation.warnings:
            print(f"WARNING: {doc_path} has {len(validation.warnings)} warnings:")
            for warning in validation.warnings:
                print(f"  - {warning}")

    doc = parse_design_document(doc_path)
    if not doc:
        print(f"ERROR: Could not parse document: {doc_path}", file=sys.stderr)
        return False

    content = doc.content if not sanitize else sanitize_content(doc.content)
    comment = f"""{comment_prefix}## Design Document: {doc.title}

| Property | Value |
|----------|-------|
| UUID | `{doc.uuid}` |
| Type | {doc.doc_type} |
| Status | {doc.status} |
| Source | `{doc_path}` |
| Attached | {datetime.now().strftime("%Y-%m-%d %H:%M")} |

<details>
<summary>Full Document Content</summary>

{content}

</details>

---
*Attached by Integrator Agent*
"""

    result = run_gh_command(["issue", "comment", str(issue_number), "--body", comment])
    if result.returncode != 0:
        print(f"ERROR: Failed to attach document: {result.stderr}", file=sys.stderr)
        return False

    print(f"ATTACHED: {doc.uuid} -> Issue #{issue_number}")
    return True


def attach_multiple_documents(
    issue_number: int,
    doc_paths: list[Path],
    sanitize: bool = True,
    validate: bool = True,
    strict: bool = False,
) -> int:
    """Attach multiple design documents to an issue. Returns count of attached documents."""
    if validate:
        valid_paths, invalid_paths = validate_documents(
            doc_paths, strict=strict, quiet=False
        )
        if invalid_paths:
            print(
                f"\nERROR: {len(invalid_paths)} document(s) failed validation:",
                file=sys.stderr,
            )
            for path in invalid_paths:
                print(f"  - {path}", file=sys.stderr)
            print("Fix validation errors or use --no-validate to skip", file=sys.stderr)
            return 0
        doc_paths = valid_paths

    docs: list[DesignDocument] = []
    for path in doc_paths:
        doc = parse_design_document(path)
        if doc:
            docs.append(doc)
        else:
            print(f"WARNING: Skipping unparseable document: {path}", file=sys.stderr)

    if not docs:
        print("ERROR: No valid documents to attach", file=sys.stderr)
        return 0

    toc_lines = ["## Design Documents Attached\n"]
    toc_lines.append("| # | UUID | Title | Type | Status |")
    toc_lines.append("|---|------|-------|------|--------|")
    for i, doc in enumerate(docs, 1):
        toc_lines.append(
            f"| {i} | `{doc.uuid}` | {doc.title} | {doc.doc_type} | {doc.status} |"
        )
    toc_lines.append("")

    doc_sections: list[str] = []
    for i, doc in enumerate(docs, 1):
        content = doc.content if not sanitize else sanitize_content(doc.content)
        section = f"""
---

### {i}. {doc.title}

**UUID**: `{doc.uuid}` | **Type**: {doc.doc_type} | **Status**: {doc.status}

<details>
<summary>Document Content</summary>

{content}

</details>
"""
        doc_sections.append(section)

    comment = (
        "\n".join(toc_lines)
        + "\n".join(doc_sections)
        + f"""

---
*{len(docs)} documents attached by Integrator Agent at {datetime.now().strftime("%Y-%m-%d %H:%M")}*
"""
    )

    result = run_gh_command(["issue", "comment", str(issue_number), "--body", comment])
    if result.returncode != 0:
        print(f"ERROR: Failed to attach documents: {result.stderr}", file=sys.stderr)
        return 0

    print(f"ATTACHED: {len(docs)} documents -> Issue #{issue_number}")
    for doc in docs:
        print(f"  - {doc.uuid}: {doc.title}")
    return len(docs)


def get_issue_info(issue_number: int) -> Optional[IssueMetadata]:
    """Get metadata for an issue."""
    result = run_gh_command(
        ["issue", "view", str(issue_number), "--json", "number,title,state,labels,url"]
    )
    if result.returncode != 0:
        return None

    data = json.loads(result.stdout)
    return IssueMetadata(
        number=data["number"],
        title=data["title"],
        state=data["state"],
        labels=[lbl["name"] for lbl in data.get("labels", [])],
        url=data.get("url", ""),
    )


def search_issues(query: str, limit: int = 20) -> list[IssueMetadata]:
    """Search issues with GitHub search syntax."""
    result = run_gh_command(
        [
            "issue",
            "list",
            "--search",
            query,
            "--limit",
            str(limit),
            "--json",
            "number,title,state,labels,url",
        ]
    )

    if result.returncode != 0:
        return []

    data = json.loads(result.stdout)
    return [
        IssueMetadata(
            number=item["number"],
            title=item["title"],
            state=item["state"],
            labels=[lbl["name"] for lbl in item.get("labels", [])],
            url=item.get("url", ""),
        )
        for item in data
    ]


def verify_closure_requirements(issue_number: int) -> tuple[bool, list[str]]:
    """Verify that an issue meets closure requirements. Returns (can_close, issues_list)."""
    issues: list[str] = []

    result = run_gh_command(
        ["issue", "view", str(issue_number), "--json", "body,state,labels,closedBy"]
    )
    if result.returncode != 0:
        return False, ["Could not fetch issue details"]

    data = json.loads(result.stdout)

    if data.get("state") == "CLOSED":
        return True, ["Issue already closed"]

    body = data.get("body", "")
    labels = [lbl["name"] for lbl in data.get("labels", [])]

    unchecked = re.findall(r"- \[ \](.+)", body)
    if unchecked:
        issues.append(f"Unchecked items: {len(unchecked)}")
        for item in unchecked[:3]:
            issues.append(f"  - {item.strip()}")

    result = run_gh_command(
        [
            "pr",
            "list",
            "--search",
            f"is:merged linked:issue:{issue_number}",
            "--json",
            "number,title,state",
        ]
    )

    if result.returncode == 0:
        prs = json.loads(result.stdout)
        merged_prs = [pr for pr in prs if pr.get("state") == "MERGED"]
        if not merged_prs:
            issues.append("No merged PR linked to this issue")
    else:
        issues.append("Could not check linked PRs")

    required_labels = ["status:done", "verified"]
    for label in required_labels:
        if label not in labels:
            issues.append(f"Missing label: {label}")

    can_close = len(issues) == 0
    if can_close:
        print(f"Issue #{issue_number} meets closure requirements")
    else:
        print(f"Issue #{issue_number} has {len(issues)} blocking issues:")
        for issue in issues:
            print(f"  - {issue}")

    return can_close, issues
